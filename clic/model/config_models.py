# clic/config_models.py
from typing import Literal, Union, List, Optional
from pydantic import BaseModel, Field, root_validator

# ==============================================================================
#  1. Low-Level "Component" Models
#  These models represent specific, reusable blocks of parameters that are
#  nested inside the main configuration sections.
# ==============================================================================

class BathConfig(BaseModel):
    """
    Represents the [model.parameters.bath] subsection.
    Used only for the 'anderson_impurity_model' type to define its bath.
    """
    nb: int = Field(..., gt=0, description="Number of bath sites.")
    min_e: float = Field(..., description="Minimum energy of the bath band.")
    max_e: float = Field(..., description="Maximum energy of the bath band.")
    hybridization_V: float = Field(..., description="Constant hybridization strength.")


class CiMethodConfig(BaseModel):
    """
    Represents the [solver.ci_method] subsection.
    Defines the parameters for the core Configuration Interaction algorithm.
    """
    type: Literal["sci", "fci"] = "sci"
    generator: Literal["hamiltonian_generator"] = "hamiltonian_generator"
    selector: Literal["cipsi"] = "cipsi"
    num_roots: int = Field(1, gt=0, description="Number of eigenstates to compute.")
    max_iter: int = Field(10, gt=-1, description="Maximum number of SCI iterations.")
    conv_tol: float = Field(1e-6, gt=0, description="Energy convergence tolerance.")
    prune_thr: float = Field(1e-7, ge=0, description="Threshold for pruning determinants in SCI.")
    Nmul: Optional[float] = Field(None, description="Factor to expand the basis size at each SCI step.")


class LanczosParameters(BaseModel):
    """
    Represents the [green_function.lanczos] subsection.
    Defines parameters for the Lanczos algorithm used in the GF calculation.
    """
    L: int = Field(..., gt=0, description="Maximum number of Lanczos steps.")
    NappH: int = Field(..., ge=0, description="Number of H applications to build Krylov basis.")
    coeff_thresh: float = Field(..., ge=0, description="Coefficient threshold for wavefunction support.")



# ==============================================================================
#  2. Discriminated Unions for Polymorphic Model Parameters
#  These models handle the `type` field in the TOML file to allow for
#  different kinds of model definitions.
# ==============================================================================

class AimParameters(BaseModel):
    """Schema for [model.parameters] when type = 'anderson_impurity_model'."""
    type: Literal['anderson_impurity_model']
    M_spatial: int
    M_imp: int
    Nelec_imp: int
    Nelec: Optional[int] = None
    interaction_u: float
    mu: Union[float, Literal["u/2"]]
    bath: BathConfig

    @root_validator(pre=False, skip_on_failure=True)
    def check_sizes(cls, values):
        m_imp, m_spatial = values.get('M_imp'), values.get('M_spatial')
        if m_imp is not None and m_spatial is not None and m_imp > m_spatial:
            raise ValueError("M_imp (impurity orbitals) cannot be larger than M_spatial (total orbitals).")
        return values


class FileDataSource(BaseModel):
    """Schema for [model.parameters] when type = 'from_file'."""
    type: Literal["from_file"]
    filepath: str
    Nelec: int = Field(..., ge=0)
    spin_structure: Literal["alpha_first", "interleaved", "spatial"] = "interleaved"


class FileImpurityModelParameters(BaseModel):
    """Schema for [model.parameters] when type = 'impurity_from_file'."""
    type: Literal["impurity_from_file"]
    filepath: str
    M_imp: int
    Nelec_imp: int
    Nelec: Optional[int] = None
    spin_structure: Literal["alpha_first", "interleaved", "spatial"] = "interleaved"


class FileImpurityWithHybParameters(BaseModel):
    """Schema for [model.parameters] when type = 'impurity_with_hyb'."""
    type: Literal["impurity_with_hyb"]
    filepath: str # Path to the single H5 archive
    
    # --- Physical Parameters ---
    M_imp: int
    Nelec_imp: int
    Nelec: Optional[int] = None
    spin_structure: Literal["alpha_first", "interleaved", "spatial"] = "interleaved"

    # --- Fitting Configuration ---
    #hybfit: HybFitConfig

    # --- Output Option ---
    save_fitted_h0: bool = Field(False, description="If true, save the generated h0 back to the input HDF5 file.")

# ==============================================================================
#  3. Main Section Models
#  These models correspond directly to the main sections of the clic.toml file,
#  like [output], [model], [solver], etc.
# ==============================================================================

class OutputConfig(BaseModel):
    """
    Represents the top-level [output] section.
    Defines the base name for all output files generated by the workflow.
    """
    basename: str = "clic_run"
    plot_file: Optional[str] = None


class ModelConfig(BaseModel):
    """
    Represents the top-level [model] section.
    This is always required and defines the physical system to be solved.
    """
    model_name: str
    parameters: Union[
        AimParameters,
        FileDataSource,
        FileImpurityModelParameters,
        FileImpurityWithHybParameters
    ] = Field(..., discriminator='type')


class SolverParameters(BaseModel):
    """
    Represents the top-level [solver] section.
    If this section is present, a ground-state calculation is performed.
    """
    basis_prep_method: Literal["none", "rhf", "bath_no", "dbl_chain"]
    use_no: Literal["none", "no0"] = "none"
    ci_method: CiMethodConfig
    nelec_range: Optional[Union[tuple[int, int], Literal["auto"], None]] = None
    initial_temperature: float = 5.0


class GreenFunctionConfig(BaseModel):
    """
    Represents the top-level [green_function] section.
    If this section is present, a Green's function calculation is performed.
    """
    omega_mesh: List[Union[int, float]]
    eta: float = Field(..., gt=0)
    block_indices: Union[Literal["impurity"], List[int]]
    lanczos: LanczosParameters


class HybFitConfig(BaseModel):
    """Represents the [model.parameters.hybfit] subsection."""
    n_target_poles: int = Field(..., ge=0, description="Number of bath sites to fit PER BLOCK.")
    eta_in: float = Field(0.01,ge=0, description="Distance to the imaginary axis used to produce the hybridization")
    method: Literal["poles_reconstruction", "cost_minimization"]
    warp_kind: Literal["none","emph0"] = "none"
    warp_w0: Optional[float] = 0.01 
    eta_broad: Optional[float] = 0.0

# ==============================================================================
#  4. The Top-Level Workflow Model
#  This is the single, overarching model that validates the entire clic.toml file.
# ==============================================================================

class CalculationConfig(BaseModel):
    """
    The main Pydantic model that validates the entire clic.toml workflow file.
    It combines all the sections into a single, coherent configuration object.
    """
    output: OutputConfig
    model: ModelConfig
    hybfit: Optional[HybFitConfig] = None
    solver: Optional[SolverParameters] = None
    green_function: Optional[GreenFunctionConfig] = None
    # Add future optional steps here, e.g.:
    # self_energy: Optional[SelfEnergyConfig] = None