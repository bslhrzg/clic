]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic[?1h=[?1l>README.md
TODO.md
clic
clic.egg-info
config
docs
howto.md
pyproject.toml
python_tests
python_tests_old
session.log
tmp
venv
]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic[?1h=[?1l>/Users/bashe338/work/clic
]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic[?1h=[1m[37m...[39m[0m[?1l>]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic[?1h=[?1l>__init__.py
__pycache__
api.py
basis
fitdelta.py
green
hybfit
io_clic
lanczos
mf
model
ops
results
scripts
solve
sparsity_score.py
symmetries
totoinit.py
workflow.py
]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic[?1h=[1m[37m...[39m[0m[?1l># clic/api.py
import numpy as np
from tqdm import tqdm    # For the progress bar
from typing import Literal, Union, Optional 
from scipy.linalg import eigh,block_diag
import copy
import sys 

from clic.model import bath_transform
import clic_clib as cc # Import for Wavefunction, SlaterDeterminant
from clic.basis import basis_1p, basis_Np
from clic.ops import ops
from clic.solve import sci
from clic.mf import mf
from clic.green import plotting, gfs, green_sym
from clic.io_clic import io_utils
from clic.results import results # For type hinting
from clic.model.config_models import CalculationConfig,ModelConfig, SolverParameters, GreenFunctionConfig, OutputConfig
from clic.model import create_model_from_hyb, hamiltonians, double_chains
from clic.symmetries import symmetries


from time import time
import h5py

class Model:
    """Represents the physical system via its Hamiltonian integrals."""
    def __init__(self, h0: np.ndarray, U: np.ndarray, M_spatial: int, Nelec: int):
        self.h0 = np.ascontiguousarray(h0, dtype=np.complex128)

        print("diag h0 = ")
        for i in range(np.shape(h0)[0]):
            print(f"{i} : {np.real(h0[i,i]):.3e}")

        self.U = np.ascontiguousarray(U, dtype=np.complex128)
        self.M = M_spatial
        self.Nelec = Nelec
        # We can add u, mu etc. if basis_transforms needs them
        self.u = U[0, M_spatial, 0, M_spatial].real if U.ndim == 4 and U.shape[0] > M_spatial else 0.0

        self.is_impurity_model: bool = False
        self.imp_indices: list[int] = []
        self.Nelec_imp: int | None = None

class GroundStateSolver:
    """The main API endpoint for running a ground state calculation."""
    def __init__(self, model: Model, settings: dict | SolverParameters):
        self.model = model
        # If raw dict is passed, validate it with our Pydantic model
        if isinstance(settings, dict):
            self.settings = SolverParameters(**settings)
        else:
            self.settings = settings
        

        self.result: results.ThermalGroundState | None = None 
        self.transformation_matrix = None # Store the transform here

    def _prepare_basis(self):
        method = self.settings.basis_prep_method
        print(f"Preparing one-particle basis using method: '{method}'")
        if method == "none":
            return
        
        elif method == 'rhf':
            hmf, es, Vs, rho = mf.mfscf(self.model.h0,self.model.U,self.model.Nelec,spinsym_only=True)
            #hmf, es, Vs, rho = mf.mfscf_(self.model.h0,self.model.U,self.model.Nelec)
            h0,U_mat = basis_1p.basis_change_h0_U(self.model.h0,self.model.U,Vs)
            self.model.h0 = h0
            self.model.U = U_mat
            self.transformation_matrix = Vs

        elif method in ["dbl_chain","bath_no"]:

            if len(self.model.imp_indices) == 1:

                # self.model.h0 is the full 2M x 2M matrix for both spins
                # We operate on one spin sector (M x M)
                h0_spin = np.real(self.model.h0[:self.model.M, :self.model.M])
                Nelec_half = self.model.Nelec // 2 

                if method == "dbl_chain":
                    h_final_matrix, C_spin = bath_transform.get_double_chain_transform(
                        h0_spin, self.model.u, Nelec_half
                    )
                else :
                    h_final_matrix, C_spin = bath_transform.get_natural_orbital_transform(
                        h0_spin, self.model.u, Nelec_half
                    )


                h_final_matrix[0, 0] = -self.model.u / 2
              
                C = block_diag(C_spin, C_spin)
                self.model.h0 = C.conj().T @ self.model.h0 @ C
                self.transformation_matrix = C 
               

            # --- MULTI-ORBITAL IMPURITY CASE ---
            else: 
                print(f"Applying multi-orbital transformation for {len(self.model.imp_indices)} impurity orbitals...")
                
                # Define impurity indices (now expecting global SPATIAL indices)
                imp_indices_spatial = self.model.imp_indices 
                
                # Choose which transformation to run based on the method
                if method == "dbl_chain":
                    
                    # Get the mean field h to get impurity occupation not crazy
                    hmf,_,_,rho_mf = mf.mfscf(self.model.h0,self.model.U,self.model.Nelec)

                    # Double chain expects a interleaved convention
                    hmf_ab = basis_1p.transform_h0_alphafirst_to_interleaved(hmf)
                    rhomf_ab = basis_1p.transform_h0_alphafirst_to_interleaved(rho_mf)

                    Nimp = len(self.model.imp_indices) * 2
                    print(f"DEBUG, Nimp = {Nimp}")
                    hdc_ab, C_ab, meta = double_chains.double_chain_by_blocks(hmf_ab,rhomf_ab,
                                                                        Nimp,self.model.Nelec,
                                        symmetries.analyze_symmetries, double_chains.get_double_chain_transform_multi)

                    hdc = basis_1p.transform_integrals_interleaved_to_alphafirst(hdc_ab)
                    C = basis_1p.transform_integrals_interleaved_to_alphafirst(C_ab)
                    
                    self.model.h0 = C.conj().T @ self.model.h0 @ C 
                    self.transformation_matrix = C

                
                elif method == "bath_no":
                    # Call the new, simpler function
                    h_final, C_total = bath_transform.get_multi_orbital_natural_orbital_transform(
                        self.model.h0, 
                        self.model.U, 
                        self.model.Nelec, 
                        imp_indices_spatial, # Pass the SPATIAL indices
                    )
                
                    # Transform the U tensor using the final transformation matrix
                    _ , U_final = basis_1p.basis_change_h0_U(self.model.h0, self.model.U, C_total)
                    
                    # Update the model
                    self.model.h0 = h_final
                    self.model.U = U_final
                    self.transformation_matrix = C_total
                
        else:
            raise NotImplementedError(f"Basis prep method '{method}' not implemented.")


    def _run_sci(self, seed: list[cc.SlaterDeterminant], max_iter_override: int | None = None) -> results.NelecLowEnergySubspace:
        """A helper to run the SCI calculation with a given starting seed."""
        ci_settings = self.settings.ci_method
        max_iter = max_iter_override if max_iter_override is not None else ci_settings.max_iter
        num_roots = 1 if max_iter_override is not None else ci_settings.num_roots
        print(f"Running SCI with max_iter={max_iter}, num_roots={num_roots} and seed size {len(seed)}...")
        
        result_obj = sci.selective_ci(
            h0=self.model.h0, 
            U=self.model.U,
            C=self.transformation_matrix,
            M=self.model.M, 
            Nelec=self.model.Nelec,
            seed=seed,  # Use the provided seed
            generator=sci.hamiltonian_generator, 
            selector=sci.cipsi_select,
            num_roots=num_roots,
            max_iter=max_iter, 
            conv_tol=ci_settings.conv_tol,
            prune_thr=ci_settings.prune_thr,
            Nmul=ci_settings.Nmul, 
            verbose=True
        )
        return result_obj

    def solve(self) -> results.ThermalGroundState:
        """Runs the full workflow, including the optional NO step."""

        # Create a deep copy of the original model BEFORE any transformations are applied
        original_model = copy.deepcopy(self.model)

        # Edge case, Nelec = 0 
        if self.model.Nelec == 0 :
            vacuum_det = cc.SlaterDeterminant(self.model.M, [], [])
            psis = [cc.Wavefunction(self.model.M, [vacuum_det], [0+0j])]
            self.result = results.NelecLowEnergySubspace(M=self.model.M,Nelec=0,
                energies=[0],
                wavefunctions=psis,
                basis=[vacuum_det],
                transformation_matrix=None
            )
            # Even for this simple case, we create the full ThermalGroundState object
            thermal_result = results.ThermalGroundState(
                results_by_nelec={0: self.result},
                base_model=original_model,
                temperature=self.settings.initial_temperature
            )
            self.result = thermal_result
            return self.result


        self._prepare_basis()

        ci_settings = self.settings.ci_method
        if ci_settings.type == "fci":
            # FCI logic doesn't use NOs, handle it separately and early.
            print("Running FCI calculation...")
            result_obj = sci.do_fci(
                h0=self.model.h0, U=self.model.U, M=self.model.M, Nelec=self.model.Nelec, num_roots=ci_settings.num_roots,Sz=0, verbose=True)

        elif ci_settings.type == "sci":
            # --- Determine the initial seed for the first (or only) SCI run ---
            if self.settings.basis_prep_method == 'rhf':
                initial_seed = basis_Np.get_rhf_determinant(self.model.Nelec, self.model.M)
            else:
                if self.model.is_impurity_model:
                    initial_seed = basis_Np.get_imp_starting_basis(
                        np.real(self.model.h0), self.model.Nelec, self.model.Nelec_imp, self.model.imp_indices)
                else: 
                    initial_seed = basis_Np.get_starting_basis(np.real(self.model.h0), self.model.Nelec)
            
            # --- "no0" Workflow ---
            if self.settings.use_no == 'no0':
                print("\n--- Starting 'no0' procedure: calculating Natural Orbitals ---")
                
                # 1. Run a preliminary SCI calculation
                pre_sci_result = self._run_sci(seed=initial_seed, max_iter_override=1)
                psi_approx = pre_sci_result.ground_state_wavefunction
                
                # 2. Compute 1-RDM and get correctly sorted NO transformation matrix
                print("Calculating 1-RDM from approximate wavefunction...")
                rdm1_spatial = self.get_one_rdm(wavefunction=psi_approx, spatial=True)
                occ_numbers, C_no_spin_unsorted = eigh(rdm1_spatial)
                sort_indices = np.argsort(occ_numbers)[::-1]
                C_no_spin = C_no_spin_unsorted[:, sort_indices]
                C_no = block_diag(C_no_spin, C_no_spin)
                
                # 3. Transform the Hamiltonian into the NO basis
                print("Transforming Hamiltonian to Natural Orbital basis...")
                h0_no, U_no = basis_1p.basis_change_h0_U(self.model.h0, self.model.U, C_no)
                self.model.h0 = h0_no
                self.model.U = U_no
                
                # 4. Compose the transformation matrices
                if self.transformation_matrix is not None:
                    self.transformation_matrix = self.transformation_matrix @ C_no
                else:
                    self.transformation_matrix = C_no
                
                print("--- 'no0' procedure finished. Starting final calculation. ---\n")
                
                # The seed for the final calculation is the basis from the pre-SCI run.
                # The determinants themselves don't change, they are just labels. We are now simply
                # re-interpreting them in the new NO basis where the Hamiltonian has changed.
                final_seed = pre_sci_result.basis

                # 6. Run the final SCI 
                result_obj = self._run_sci(seed=final_seed)

            else: # --- Standard SCI Workflow (use_no == 'none') ---
                result_obj = self._run_sci(seed=initial_seed)

        # Finalize and store results
        result_obj.transformation_matrix = self.transformation_matrix
        
        print(f"\nCalculation finished. Ground state energy = {result_obj.ground_state_energy:.12f}")

        # Instantiate the final results object with the computed subspace and original model
        final_thermal_state = results.ThermalGroundState(
            results_by_nelec={result_obj.Nelec: result_obj},
            base_model=original_model, # Pass the whole original model
            temperature=self.settings.initial_temperature
        )

        self.result = final_thermal_state
        return self.result


    def get_one_rdm(self, wavefunction: cc.Wavefunction | None = None, spatial: bool = False) -> np.ndarray:
        """Computes the 1-RDM. Can compute for a provided wavefunction."""
        if wavefunction is None:
            if not self.result:
                raise RuntimeError("Solver has not been run and no wavefunction was provided.")
            # We need the ground state wavefunction from the correct Nelec sector
            _, _, wavefunction = self.result.find_absolute_ground_state()

        rdm = ops.one_rdm(wavefunction, self.model.M)
        
        if spatial:
            return rdm[:self.model.M, :self.model.M]
        return rdm
    
    def compute_stats(self, wavefunction: cc.Wavefunction):
        if self.model.is_impurity_model:
            imp_indices_spinfull = self.model.imp_indices + [iimp + self.model.M for iimp in self.model.imp_indices]
            gamma = ops.one_rdm(wavefunction,self.model.M,block=imp_indices_spinfull)
            occs = np.diag(gamma)
            print("* Occupations -------------")
            print(f"total: {np.sum(np.real(occs)):.3e}")
            for (i,iimp) in enumerate(imp_indices_spinfull):
                print(f"{i:>6} : {np.real(occs[i]):.3e}")
        else:
            gamma = ops.one_rdm(wavefunction,self.model.M)
            occs = np.diag(gamma)
            print(f"Total occupation: {np.sum(occs)}")
            for i in range(len(occs)):
                print(f"occ[{i}] = {np.real(occs[i]):.3e}")


    def save_result(self, filename: str):
        """Saves the ThermalGroundState result to a single HDF5 file."""
        if not self.result:
            raise RuntimeError("Solver has not been run yet.")
        self.result.save(filename)
        
class FockSpaceSolver:
    """
    API endpoint for finding the low-energy subspace across a range of particle
    numbers (Nelec). It orchestrates multiple fixed-Nelec calculations and
    combines them into a ThermalGroundState object for thermodynamic analysis.
    """
    def __init__(self, model: Model, settings: dict | SolverParameters, nelec_range: Union[tuple[int, int], Literal["auto"]]):
        self.base_model = model
        
        if isinstance(settings, dict):
            self.settings = SolverParameters(**settings)
        else:
            self.settings = settings
            
        self.nelec_setting = nelec_range
        self.result: results.ThermalGroundState | None = None

    def _solve_single_nelec(self, nelec: int, cache: dict) -> results.ThermalGroundState:
        """
        Helper to run a calculation for a single Nelec, using a cache.
        Returns a ThermalGroundState object, which contains the NelecLowEnergySubspace.
        """
        if nelec in cache:
            return cache[nelec]

        print(f"\n--- Solving for Nelec = {nelec} ---")
        current_model = copy.deepcopy(self.base_model)
        current_model.Nelec = nelec
        
        solver = GroundStateSolver(current_model, self.settings)
        # solver.solve() returns a ThermalGroundState object
        nelec_result_thermal = solver.solve() 
        
        cache[nelec] = nelec_result_thermal
        return nelec_result_thermal

    def _find_optimal_nelec(self) -> dict[int, results.NelecLowEnergySubspace]:
        """
        Iteratively searches for the Nelec that minimizes the ground state energy.
        Returns a dictionary of NelecLowEnergySubspace results centered around the minimum.
        """
        if not self.base_model.is_impurity_model:
            raise ValueError("Automatic Nelec search is only supported for impurity models.")

        nelec_start = self.base_model.Nelec
        print(f"\n--- Starting Automatic Search for Optimal Nelec (start = {nelec_start}) ---")

        energies = {}
        results_cache = {} # Caches ThermalGroundState objects
        subspace_cache = {} # Caches NelecLowEnergySubspace objects

        # --- Initial Point ---
        print(f"Calculating for starting Nelec = {nelec_start}...")
        result_thermal = self._solve_single_nelec(nelec_start, results_cache)
        _, e0, _ = result_thermal.find_absolute_ground_state()
        energies[nelec_start] = e0
        subspace_cache[nelec_start] = result_thermal.results_by_nelec[nelec_start]
        
        # --- Search Upwards ---
        print("\n--- Searching for minimum in increasing Nelec direction ---")
        nelec_curr = nelec_start
        while True:
            nelec_next = nelec_curr + 1
            if nelec_next > 2 * self.base_model.M:
                print("Reached maximum possible electrons. Stopping upward search.")
                break

            e_curr = energies[nelec_curr]
            result_thermal_next = self._solve_single_nelec(nelec_next, results_cache)
            _, e_next, _ = result_thermal_next.find_absolute_ground_state()
            energies[nelec_next] = e_next
            subspace_cache[nelec_next] = result_thermal_next.results_by_nelec[nelec_next]
            
            print(f"E({nelec_curr}) = {e_curr:.6f}, E({nelec_next}) = {e_next:.6f}")
            if e_next >= e_curr:
                print("Energy is no longer decreasing. Stopping upward search.")
                break
            nelec_curr = nelec_next

        # --- Search Downwards ---
        print("\n--- Searching for minimum in decreasing Nelec direction ---")
        nelec_curr = nelec_start
        while True:
            nelec_next = nelec_curr - 1
            if nelec_next < 0:
                print("Reached zero electrons. Stopping downward search.")
                break

            e_curr = energies[nelec_curr]
            result_thermal_next = self._solve_single_nelec(nelec_next, results_cache)
            _, e_next, _ = result_thermal_next.find_absolute_ground_state()
            energies[nelec_next] = e_next
            subspace_cache[nelec_next] = result_thermal_next.results_by_nelec[nelec_next]
            
            print(f"E({nelec_curr}) = {e_curr:.6f}, E({nelec_next}) = {e_next:.6f}")
            if e_next >= e_curr:
                print("Energy is no longer decreasing. Stopping downward search.")
                break
            nelec_curr = nelec_next
            
        # --- Find minimum and collect results ---
        nelec_min = min(energies, key=energies.get)
        
        print(f"\n--- Minimum energy found at Nelec = {nelec_min} (E = {energies[nelec_min]:.8f}) ---")
        print("Collecting results for thermal state around the minimum.")

        final_subspaces = {}
        for nelec_final in [nelec_min - 1, nelec_min, nelec_min + 1]:
            if 0 <= nelec_final <= 2 * self.base_model.M:
                if nelec_final in subspace_cache:
                    final_subspaces[nelec_final] = subspace_cache[nelec_final]
                else:
                    # This case should be rare but is included for robustness
                    result_thermal = self._solve_single_nelec(nelec_final, results_cache)
                    final_subspaces[nelec_final] = result_thermal.results_by_nelec[nelec_final]
        
        return final_subspaces


    def solve(self, initial_temperature: float = 5.0) -> results.ThermalGroundState:
        """
        Runs the full workflow for each Nelec and returns a combined result.
        If nelec_setting is 'auto', it finds the optimal Nelec first.
        """
        all_subspaces = {}

        if self.nelec_setting == "auto":
            all_subspaces = self._find_optimal_nelec()
        else:
            # Original behavior for a fixed range
            nelec_range = range(self.nelec_setting[0], self.nelec_setting[1] + 1)
            print(f"\n--- Starting Fock Space Calculation for Nelec in {list(nelec_range)} ---")
            results_cache = {} # Caches ThermalGroundState objects
            for nelec in nelec_range:
                # _solve_single_nelec returns a full ThermalGroundState object
                result_thermal = self._solve_single_nelec(nelec, results_cache)
                # We only need the NelecLowEnergySubspace from it
                all_subspaces[nelec] = result_thermal.results_by_nelec[nelec]
        
        # Instantiate the final results object with all computed subspaces and the base model
        self.result = results.ThermalGroundState(
            results_by_nelec=all_subspaces,
            base_model=self.base_model, # Pass the entire base model
            temperature=initial_temperature
        )

        self.result.prune()
        
        # Report the absolute ground state found
        gs_nelec, gs_energy, _ = self.result.find_absolute_ground_state()
        print("\n--- Fock Space Calculation Finished ---")
        print(f"Absolute ground state found at Nelec = {gs_nelec} with E = {gs_energy:.12f}")
        
        return self.result


    def save_result(self, filename: str):
        if not self.result:
            raise RuntimeError("Solver has not been run yet.")
        self.result.save(filename)


# ----------------------------------------------------------------------------------

class GreenFunctionCalculator:
    """
    Calculates the thermally-averaged Green's function from a saved ThermalGroundState.
    """
    def __init__(self, gf_config: GreenFunctionConfig, output_config: OutputConfig, ground_state_filepath: str):
        self.gf_config = gf_config
        self.output_config = output_config
        self.ground_state_filepath = ground_state_filepath
        self.thermal_state: results.ThermalGroundState | None = None

    def load_thermal_state(self):
        """Loads the ThermalGroundState from HDF5 and prepares it for calculation."""
        filepath = self.ground_state_filepath
        print(f"Loading thermal state from HDF5 file '{filepath}'...")
        try:
            self.thermal_state = results.ThermalGroundState.load(filepath)
        except (FileNotFoundError, KeyError) as e:
            raise RuntimeError(f"Failed to load ground state file: {e}")
        
        print(f"Thermal state loaded. Initial temperature: {self.thermal_state.temperature:.1f} K.")
        print(f"Prepared thermal state with {len(self.thermal_state._all_states)} states for GF calculation.")

    def run(self, ground_state_result: Optional[results.ThermalGroundState] = None) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Runs the thermally-averaged Green's function calculation.
        If ground_state_result is provided, it uses it directly.
        Otherwise, it loads from the file specified in the config.
        """
        if ground_state_result:
            print("Using in-memory ground state result from solver step.")
            self.thermal_state = ground_state_result
        else:
            self.load_thermal_state() # This method loads from file

        p_gf = self.gf_config
        p_lanczos = self.gf_config.lanczos
        ws = np.linspace(p_gf.omega_mesh[0], p_gf.omega_mesh[1], int(p_gf.omega_mesh[2]))


        if p_gf.block_indices == "impurity":
            if not self.thermal_state.is_impurity_model:
                raise ValueError("GF block set to 'impurity' but loaded state is not an impurity model.")
            target_indices = sorted(self.thermal_state.imp_indices + [i + self.thermal_state.M for i in self.thermal_state.imp_indices])
        else:
            target_indices = sorted(list(set(p_gf.block_indices)))

        print(f"\nTargeting Green's function block for indices: {target_indices}")
        
        num_target = len(target_indices)
        # We will calculate the diagonal elements for now
        # This can be extended to the full block later if needed.
        G_total_diag = np.zeros((len(ws), num_target), dtype=np.complex128)
        
        # Cache for transformed Hamiltonians to avoid redundant calculations
        hamiltonian_cache = {}
        base_h0 = self.thermal_state.base_h0
        base_U = self.thermal_state.base_U
        M = self.thermal_state.M

        # Main loop over all states in the thermal ensemble
        iterator = zip(self.thermal_state._all_states, self.thermal_state.boltzmann_weights)
        for (state_info, weight) in tqdm(iterator, total=len(self.thermal_state._all_states), desc="Processing thermal states"):
            e_n, nelec_n, psi_n = state_info

            # Get the correct transformed Hamiltonian for this state's Nelec sector
            if nelec_n not in hamiltonian_cache:
                subspace = self.thermal_state.results_by_nelec[nelec_n]
                C = subspace.transformation_matrix
                if C is None:
                    h0_n, U_n = base_h0, base_U
                else:
                    h0_n, U_n = basis_1p.basis_change_h0_U(base_h0, base_U, C)
                
                one_bh_n = ops.get_one_body_terms(h0_n, M)
                two_bh_n = ops.get_two_body_terms(U_n, M)
                hamiltonian_cache[nelec_n] = (h0_n, U_n, one_bh_n, two_bh_n)
            
            h0_n, U_n, one_bh_n, two_bh_n = hamiltonian_cache[nelec_n]


            tgf0 = time()


            #gfmeth = "block"
            gfmeth = "scalar_continued_fraction"
            #gfmeth = "time_prop"

            G_sub_block_n = green_sym.get_green_block(M, psi_n, e_n, p_lanczos.NappH, p_gf.eta, 
                                                      h0_n, U_n, ws,target_indices, gfmeth, 
                                                      one_bh_n,two_bh_n, p_lanczos.coeff_thresh, p_lanczos.L
                                                      )
 
            # For now we only look at the diagonal one
            # Add the diagonal of the fully constructed sub-block to the thermal average.
            for i in range(num_target):
                G_total_diag[:, i] += weight * G_sub_block_n[:, i, i]

            tgf1 = time()
            print(f"DEBUG: gf time: {tgf1 - tgf0:.4f}s for method {gfmeth} with symmetry")
            
        print("\nThermally-averaged calculation finished.")
        A_w_total = -(1 / np.pi) * np.imag(G_total_diag)
        
        # Save and plot the final, thermally-averaged results
        #if self.settings.output.gf_diag_txt_file:
        dodump=True 
        if dodump:
            io_utils.dump(
                A_w_total,
                ws,
                'A_w_thermal',
            )

        if self.output_config.plot_file:
            plotting.plot_spectral_function(
                ws, A_w_total, list(range(num_target)),
                f"Thermally-Averaged Spectral Function (T={self.thermal_state.temperature}K)",
                self.output_config.plot_file
            )
        
        return ws, G_total_diag, A_w_total
        
 
# ----------------------------------------------------------------------------------

def create_model_from_config(config: CalculationConfig) -> Model:
    """
    Builds the API Model object from a validated configuration, handling
    automatic Nelec calculation for impurity models.
    """
    model_config = config.model
    p = model_config.parameters
    h0, U = None, None
    M = 0

    if p.type in ['anderson_impurity_model', 'impurity_from_file']:
        if p.type == 'anderson_impurity_model':
            # First, build the integrals so we have h0
            u = p.interaction_u
            mu = u / 2.0 if p.mu == "u/2" else p.mu
            e_bath = np.linspace(p.bath.min_e, p.bath.max_e, p.bath.nb)
            V_bath = np.full(p.bath.nb, p.bath.hybridization_V)
            
            M = p.M_spatial
            h0, U = hamiltonians.get_impurity_integrals(M, u, e_bath, V_bath, mu)

            # Now, determine the total number of electrons
            if p.Nelec is None:
                # Automatic calculation is needed
                nelec_bath = hamiltonians.calculate_bath_filling(h0, p.M_imp)
                nelec_total = p.Nelec_imp + nelec_bath
                print(f"INFO: 'Nelec' not specified. Automatically determined bath filling: {nelec_bath}.")
                print(f"      Total Nelec set to {p.Nelec_imp} (imp) + {nelec_bath} (bath) = {nelec_total}.")
            else:
                # User provided a value, so we use it
                nelec_total = p.Nelec
                print(f"INFO: Using user-provided total Nelec = {nelec_total}.")

        
        elif p.type == 'impurity_from_file':
            print(f"Loading impurity model integrals from file: {p.filepath}")
            # First, load the integrals so we have h0 and M
            h0, U, M = hamiltonians.get_integrals_from_file(p.filepath, p.spin_structure)
            print(f"M = {M}")
            print("diag h0 = ")
            print(np.diag(h0))

            # Now, use the same logic as the AIM to determine total Nelec
            if p.Nelec is None:
                # Automatic calculation is needed
                nelec_bath = hamiltonians.calculate_bath_filling(h0, p.M_imp)
                nelec_total = p.Nelec_imp + nelec_bath
                print(f"INFO: 'Nelec' not specified. Automatically determined bath filling: {nelec_bath}.")
                print(f"      Total Nelec set to {p.Nelec_imp} (imp) + {nelec_bath} (bath) = {nelec_total}.")
            else:
                # User provided a value, so we use it
                nelec_total = p.Nelec
                print(f"INFO: Using user-provided total Nelec = {nelec_total}.")
            
        model = Model(h0=h0, U=U, M_spatial=M, Nelec=nelec_total)
        model.is_impurity_model = True
        model.imp_indices = list(range(p.M_imp)) 
        model.Nelec_imp = p.Nelec_imp
        return model

    elif p.type == 'from_file':
        print(f"Loading model integrals from file: {p.filepath}")
        h0, U, M = hamiltonians.get_integrals_from_file(p.filepath, p.spin_structure)
        # For this type, Nelec is required by Pydantic, so no calculation needed
        return Model(h0=h0, U=U, M_spatial=M, Nelec=p.Nelec)
    

    elif p.type == 'impurity_with_hyb':
        print(f"Building model from hybridization function fit in '{p.filepath}'...")
        
        # --- Step 1: Load inputs from HDF5 archive ---
        with h5py.File(p.filepath, 'r') as f:
            if 'h_dft' not in f or 'U_mat' not in f or 'hyb' not in f or 'w' not in f:
                raise KeyError(f"HDF5 file '{p.filepath}' is missing one of required datasets: h_dft, U_mat, hyb, w")
            h_imp = f['h_dft'][:]
            U_imp = f['U_mat'][:] 
            delta = f['hyb'][:]
            omega = f['w'][:]

        # --- Step 2: Call the builder to get the fitted h0 ---
        if config.hybfit.n_target_poles > 0 :

            full_h0 = create_model_from_hyb.build_model_from_hyb(h_imp, omega, delta, config.hybfit)

        else : 
            print(f"*"*42)
            print("n_target_poles = 0 --> Hubbard-I Approximation")
            print(f"NOT IMPLEMENTED YET")
            sys.exit(1)
            full_h0 = h_imp


        # --- Step 3 (Optional): Save the result back to the HDF5 file ---
        if p.save_fitted_h0:
            print(f"Saving the newly generated 'h0' matrix back to '{p.filepath}'...")
            with h5py.File(p.filepath, 'a') as f: # 'a' mode for read/write/append
                if 'h0' in f:
                    print("  WARNING: Overwriting existing 'h0' dataset.")
                    del f['h0']
                f.create_dataset('h0', data=full_h0)

        # --- Step 4: Construct the full U matrix and Model object ---
        M_total_spinfull = full_h0.shape[0]
        M_total_spatial = M_total_spinfull // 2
        
        # Pad the U matrix to the full size of the new hamiltonian
        # Assumes U_imp is dense (4-index tensor)
        full_U = np.zeros((M_total_spinfull,)*4, dtype=U_imp.dtype)
        imp_size = U_imp.shape[0]
        halfimp = imp_size // 2

        impindex = [i for i in range(halfimp)] + [i for i in range(M_total_spatial, M_total_spatial+halfimp)]
        full_U[np.ix_(impindex, impindex, impindex, impindex)] = U_imp

        print("DEBUG: SAVING h0/U in api.py")
        np.save("h0fitted.npy",full_h0)
        np.save("U.npy",U_imp) 
        
        # --- Step 5: Determine Nelec (same logic as before) ---
        if p.Nelec is None:
            nelec_bath = hamiltonians.calculate_bath_filling(full_h0, p.M_imp)
            nelec_total = p.Nelec_imp + nelec_bath
            print(f"INFO: 'Nelec' not specified. Automatically determined bath filling: {nelec_bath}.")
            print(f"      Total Nelec set to {p.Nelec_imp} (imp) + {nelec_bath} (bath) = {nelec_total}.")
        else:
            # User provided a value, so we use it
            nelec_total = p.Nelec
            print(f"INFO: Using user-provided total Nelec = {nelec_total}.")
        
        model = Model(h0=full_h0, U=full_U, M_spatial=M_total_spatial, Nelec=nelec_total)
        model.is_impurity_model = True
        model.imp_indices = list(range(p.M_imp)) 
        model.Nelec_imp = p.Nelec_imp
        return model

    else:
        # This case should be unreachable if Pydantic validation is working
        print(f"ERROR: Unknown model parameter type '{p.type}'", file=sys.stderr)
        sys.exit(1)



]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic[?1h=[1m[37m...[39m[0m[?1l># clic/workflow.py
from typing import Optional

# High-level logic imports from the API and helpers
from .api import create_model_from_config,GroundStateSolver, FockSpaceSolver, GreenFunctionCalculator
from clic.model.config_models import CalculationConfig
from clic.results import results
from clic.io_clic.io_utils import *
from clic.results.postprocessing import StateAnalyzer


def run_workflow(config: CalculationConfig):
    """
    Orchestrates the entire calculation based on the parsed config.
    """
    print("--- Starting CLIC Workflow ---")

    # --- 1. Model Creation (always happens) ---
    print_header("MODEL INSTANTIATION")
    print("\n[Step 1/3] Creating model...")
    model = create_model_from_config(config)
    ground_state_result: Optional[results.ThermalGroundState] = None

    # The expected filename for the ground state is always derived from the output basename.
    # Define it here so it's always available.
    gs_filename = f"{config.output.basename}_gs.h5"

    # --- 2. Solver Execution (if configured) ---
    print_header("SOLVING MODEL")

    if config.solver:
        print("\n[Step 2/3] Solver section found. Running ground state calculation...")
        
        # Automatically select the correct solver
        if config.solver.nelec_range is not None:
            print("-> 'nelec_range' detected. Using FockSpaceSolver.")
            solver = FockSpaceSolver(
                model=model,
                settings=config.solver,
                nelec_range=config.solver.nelec_range
            )
        else:
            print("-> No 'nelec_range'. Using GroundStateSolver for fixed Nelec.")
            solver = GroundStateSolver(model, config.solver)

        ground_state_result = solver.solve()

        gs_filename = f"{config.output.basename}_gs.h5"
        print(f"Saving ground state result to '{gs_filename}'...")
        solver.save_result(gs_filename)
        
        # Optional: Run Analysis
        print("\n--- Post-Solver Analysis ---")
        analyzer = StateAnalyzer(ground_state_result, model)
        analyzer.print_analysis()

    else:
        print("\n[Step 2/3] No solver section found. Skipping ground state calculation.")

    # --- 3. Green's Function Calculation (if configured) ---
    print_header("COMPUTING GREEN FUNCTIONS")

    if config.green_function:
        print("\n[Step 3/3] Green's function section found. Running GF calculation...")
        
        calculator = GreenFunctionCalculator(
            gf_config=config.green_function,
            output_config=config.output,
            ground_state_filepath=gs_filename
        )
                
        ws, G, A = calculator.run(ground_state_result=ground_state_result)
        
    else:
        print("\n[Step 3/3] No Green's function section found. Skipping GF calculation.")

    print("\n--- CLIC Workflow Finished ---")]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic[?1h=[1m[37m...[39m[0m[?1l>]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/model[?1h=[?1l>__init__.py
__pycache__
bath_transform.py
config_models.py
create_generic_aim.py
create_model_from_hyb.py
double_chains.py
hamiltonians.py
]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/model[?1h=[1m[37m...[39m[0m[?1l># clic/config_models.py
from typing import Literal, Union, List, Optional
from pydantic import BaseModel, Field, root_validator

# ==============================================================================
#  1. Low-Level "Component" Models
#  These models represent specific, reusable blocks of parameters that are
#  nested inside the main configuration sections.
# ==============================================================================

class BathConfig(BaseModel):
    """
    Represents the [model.parameters.bath] subsection.
    Used only for the 'anderson_impurity_model' type to define its bath.
    """
    nb: int = Field(..., gt=0, description="Number of bath sites.")
    min_e: float = Field(..., description="Minimum energy of the bath band.")
    max_e: float = Field(..., description="Maximum energy of the bath band.")
    hybridization_V: float = Field(..., description="Constant hybridization strength.")


class CiMethodConfig(BaseModel):
    """
    Represents the [solver.ci_method] subsection.
    Defines the parameters for the core Configuration Interaction algorithm.
    """
    type: Literal["sci", "fci"] = "sci"
    generator: Literal["hamiltonian_generator"] = "hamiltonian_generator"
    selector: Literal["cipsi"] = "cipsi"
    num_roots: int = Field(1, gt=0, description="Number of eigenstates to compute.")
    max_iter: int = Field(10, gt=-1, description="Maximum number of SCI iterations.")
    conv_tol: float = Field(1e-6, gt=0, description="Energy convergence tolerance.")
    prune_thr: float = Field(1e-7, ge=0, description="Threshold for pruning determinants in SCI.")
    Nmul: Optional[float] = Field(None, description="Factor to expand the basis size at each SCI step.")


class LanczosParameters(BaseModel):
    """
    Represents the [green_function.lanczos] subsection.
    Defines parameters for the Lanczos algorithm used in the GF calculation.
    """
    L: int = Field(..., gt=0, description="Maximum number of Lanczos steps.")
    NappH: int = Field(..., ge=0, description="Number of H applications to build Krylov basis.")
    coeff_thresh: float = Field(..., ge=0, description="Coefficient threshold for wavefunction support.")



# ==============================================================================
#  2. Discriminated Unions for Polymorphic Model Parameters
#  These models handle the `type` field in the TOML file to allow for
#  different kinds of model definitions.
# ==============================================================================

class AimParameters(BaseModel):
    """Schema for [model.parameters] when type = 'anderson_impurity_model'."""
    type: Literal['anderson_impurity_model']
    M_spatial: int
    M_imp: int
    Nelec_imp: int
    Nelec: Optional[int] = None
    interaction_u: float
    mu: Union[float, Literal["u/2"]]
    bath: BathConfig

    @root_validator(pre=False, skip_on_failure=True)
    def check_sizes(cls, values):
        m_imp, m_spatial = values.get('M_imp'), values.get('M_spatial')
        if m_imp is not None and m_spatial is not None and m_imp > m_spatial:
            raise ValueError("M_imp (impurity orbitals) cannot be larger than M_spatial (total orbitals).")
        return values


class FileDataSource(BaseModel):
    """Schema for [model.parameters] when type = 'from_file'."""
    type: Literal["from_file"]
    filepath: str
    Nelec: int = Field(..., ge=0)
    spin_structure: Literal["alpha_first", "interleaved", "spatial"] = "interleaved"


class FileImpurityModelParameters(BaseModel):
    """Schema for [model.parameters] when type = 'impurity_from_file'."""
    type: Literal["impurity_from_file"]
    filepath: str
    M_imp: int
    Nelec_imp: int
    Nelec: Optional[int] = None
    spin_structure: Literal["alpha_first", "interleaved", "spatial"] = "interleaved"


class FileImpurityWithHybParameters(BaseModel):
    """Schema for [model.parameters] when type = 'impurity_with_hyb'."""
    type: Literal["impurity_with_hyb"]
    filepath: str # Path to the single H5 archive
    
    # --- Physical Parameters ---
    M_imp: int
    Nelec_imp: int
    Nelec: Optional[int] = None
    spin_structure: Literal["alpha_first", "interleaved", "spatial"] = "interleaved"

    # --- Fitting Configuration ---
    #hybfit: HybFitConfig

    # --- Output Option ---
    save_fitted_h0: bool = Field(False, description="If true, save the generated h0 back to the input HDF5 file.")

# ==============================================================================
#  3. Main Section Models
#  These models correspond directly to the main sections of the clic.toml file,
#  like [output], [model], [solver], etc.
# ==============================================================================

class OutputConfig(BaseModel):
    """
    Represents the top-level [output] section.
    Defines the base name for all output files generated by the workflow.
    """
    basename: str = "clic_run"
    plot_file: Optional[str] = None


class ModelConfig(BaseModel):
    """
    Represents the top-level [model] section.
    This is always required and defines the physical system to be solved.
    """
    model_name: str
    parameters: Union[
        AimParameters,
        FileDataSource,
        FileImpurityModelParameters,
        FileImpurityWithHybParameters
    ] = Field(..., discriminator='type')


class SolverParameters(BaseModel):
    """
    Represents the top-level [solver] section.
    If this section is present, a ground-state calculation is performed.
    """
    basis_prep_method: Literal["none", "rhf", "bath_no", "dbl_chain"]
    use_no: Literal["none", "no0"] = "none"
    ci_method: CiMethodConfig
    nelec_range: Optional[Union[tuple[int, int], Literal["auto"], None]] = None
    initial_temperature: float = 5.0


class GreenFunctionConfig(BaseModel):
    """
    Represents the top-level [green_function] section.
    If this section is present, a Green's function calculation is performed.
    """
    omega_mesh: List[Union[int, float]]
    eta: float = Field(..., gt=0)
    block_indices: Union[Literal["impurity"], List[int]]
    lanczos: LanczosParameters


class HybFitConfig(BaseModel):
    """Represents the [model.parameters.hybfit] subsection."""
    n_target_poles: int = Field(..., ge=0, description="Number of bath sites to fit PER BLOCK.")
    eta_in: float = Field(0.01,ge=0, description="Distance to the imaginary axis used to produce the hybridization")
    method: Literal["poles_reconstruction", "cost_minimization"]
    warp_kind: Literal["none","emph0"] = "none"
    warp_w0: Optional[float] = 0.01 
    eta_broad: Optional[float] = 0.0

# ==============================================================================
#  4. The Top-Level Workflow Model
#  This is the single, overarching model that validates the entire clic.toml file.
# ==============================================================================

class CalculationConfig(BaseModel):
    """
    The main Pydantic model that validates the entire clic.toml workflow file.
    It combines all the sections into a single, coherent configuration object.
    """
    output: OutputConfig
    model: ModelConfig
    hybfit: Optional[HybFitConfig] = None
    solver: Optional[SolverParameters] = None
    green_function: Optional[GreenFunctionConfig] = None
    # Add future optional steps here, e.g.:
    # self_energy: Optional[SelfEnergyConfig] = None]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/model[?1h=[?1l>__init__.py
__pycache__
bath_transform.py
config_models.py
create_generic_aim.py
create_model_from_hyb.py
double_chains.py
hamiltonians.py
]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/model[?1h=[1m[37m...[39m[0m[1m[37m...[39m[0m[?1l># clic/create_model_from_hyb.py
import numpy as np
from .config_models import HybFitConfig
import sys 

from clic.hybfit import utils
from clic.hybfit.process_hyb import process_hyb_cost, process_hyb_poles # import the function from its module
from clic.hybfit.process_hyb import analyze_block_fits, evaluate_full_fit_and_plots, print_summary


def build_model_from_hyb(
    h_imp: np.ndarray, 
    omega: np.ndarray, 
    hyb: np.ndarray, 
    hybfit_config: HybFitConfig
) -> np.ndarray:
    """
    Builds the full one-body hamiltonian from impurity data and a fit.
    Returns: The full h0 matrix.
    """

    n_target_poles = hybfit_config.n_target_poles
    warp_kind = hybfit_config.warp_kind
    eta = hybfit_config.eta_in

    logfile = "hybfit_details.txt"

    if hybfit_config.method == "poles_reconstruction":

        warp_k=None
        if warp_kind == "none":
            warp_k = "const"
        elif warp_kind == "emph0":
            warp_k = "asinh"
        else :
            print(f"ERROR: Unknown model parameter type '{warp_kind}'", file=sys.stderr)
            sys.exit(1)

        warp_w0 = hybfit_config.warp_w0

        H_full, map = process_hyb_poles(
        omega, hyb, h_imp, n_target_poles,n_lanczos_blocks=101, 
        warp_kind=warp_k, warp_w0=warp_w0,logfile=logfile
        )

        block_errs = analyze_block_fits(omega, hyb, map, eta=eta)
        global_errs = evaluate_full_fit_and_plots(
            omega, hyb, H_full, map, eta=eta, out_dir="hyb_plots", case_tag=""
        )

        print_summary("Fit block summary ",H_full, map)

    elif hybfit_config.method == "cost_minimization":

        broadening_Gamma = hybfit_config.eta_broad

        weight_func=None
        if warp_kind == "none":
            weight_func = "const"
        elif warp_kind == "emph0":
            weight_func = "inv2"



        print("----- COST -------")
        H_full, map = process_hyb_cost(
            omega, hyb, h_imp,
            n_target_poles=n_target_poles,
            eta_0=eta,                 # same broadening you used to generate hyb1
            bounds_e=[omega.min(), omega.max()],   # or a tighter physical window
            weight_func='const',
            broadening_Gamma=broadening_Gamma,
            logfile=logfile
            )
        
        block_errs = analyze_block_fits(omega, hyb, map, eta=eta, logfile=logfile)
        #global_errs = evaluate_full_fit_and_plots(
        #    omega, hyb, H_full, map, eta=eta, out_dir="hyb_plots", case_tag=""
        #)

        print_summary("Fit block summary ",H_full, map)

        

    return H_full]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/model[?1h=[?1l>]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic[?1h=[1m[37m...[39m[0m[?1l>]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/results[?1h=[1m[37m...[39m[0m[?1l># clic/results.py
import numpy as np
import h5py
import clic_clib as cc # for Wavefunction type hint

# Use TYPE_CHECKING block to import for type hints only, preventing circular imports
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .api import Model


class NelecLowEnergySubspace:
    """
    Holds the results of a CI calculation for a fixed particle number.
    This object contains the computed eigenstates and the basis information
    they are expressed in.
    """
    def __init__(self,
                 M: int,
                 Nelec: int,
                 energies: np.ndarray,
                 wavefunctions: list[cc.Wavefunction],
                 basis: list[cc.SlaterDeterminant],
                 transformation_matrix: np.ndarray | None = None):
        
        self.M = M
        self.Nelec = Nelec
        
        self.energies = np.asarray(energies)
        self.wavefunctions = wavefunctions
        self.basis = basis # The common basis for all wavefunctions in this result
        self.transformation_matrix = transformation_matrix # From original to final basis

    @property
    def ground_state_energy(self) -> float:
        """Convenience property for the lowest energy eigenvalue."""
        return self.energies[0]

    @property
    def ground_state_wavefunction(self) -> cc.Wavefunction:
        """Convenience property for the ground state wavefunction."""
        return self.wavefunctions[0]

    def save(self, target: str | h5py.Group):
        """
        Saves the complete result to a structured HDF5 file or group.
        
        Args:
            target: A filename (str) or an h5py.Group object.
        """
        def _save_to_group(group: h5py.Group):
            # Flatten basis occupation lists for robust HDF5 saving
            alpha_indices_flat = []
            alpha_endpoints = [0]
            for det in self.basis:
                alpha_indices_flat.extend(det.alpha_occupied_indices())
                alpha_endpoints.append(len(alpha_indices_flat))
            
            beta_indices_flat = []
            beta_endpoints = [0]
            for det in self.basis:
                beta_indices_flat.extend(det.beta_occupied_indices())
                beta_endpoints.append(len(beta_indices_flat))

            # === Metadata Group ===
            meta = group.create_group("metadata")
            meta.attrs["M"] = self.M
            meta.attrs["Nelec"] = self.Nelec
            meta.attrs["num_states"] = len(self.wavefunctions)
            meta.attrs["basis_size"] = len(self.basis)
            meta.create_dataset("energies", data=self.energies)
            
            # === Basis Group ===
            basis_gp = group.create_group("basis")
            if self.transformation_matrix is not None:
                basis_gp.create_dataset("transformation_matrix", data=self.transformation_matrix)
            
            basis_gp.create_dataset("alpha_indices_flat", data=np.asarray(alpha_indices_flat, dtype=np.int64))
            basis_gp.create_dataset("alpha_endpoints", data=np.asarray(alpha_endpoints, dtype=np.int64))
            basis_gp.create_dataset("beta_indices_flat", data=np.asarray(beta_indices_flat, dtype=np.int64))
            basis_gp.create_dataset("beta_endpoints", data=np.asarray(beta_endpoints, dtype=np.int64))
            
            # === Wavefunctions Group ===
            wf_gp = group.create_group("wavefunctions")
            for i, wf in enumerate(self.wavefunctions):
                if wf.get_basis() != self.basis:
                    raise RuntimeError(f"Basis mismatch for wavefunction {i} during save.")
                wf_gp.create_dataset(f"state_{i}_coeffs", data=wf.get_amplitudes())

        if isinstance(target, str):
            print(f"Saving Nelec={self.Nelec} subspace to file '{target}'...")
            with h5py.File(target, 'w') as f:
                _save_to_group(f)
        else: # Assumes target is an h5py.Group
            print(f"Saving Nelec={self.Nelec} subspace to HDF5 group '{target.name}'...")
            _save_to_group(target)
        
        print("Save complete.")

    @classmethod
    def load(cls, source: str | h5py.Group):
        """
        Loads a complete result from an HDF5 file or group.
        
        Args:
            source: A filename (str) or an h5py.Group object.
        """
        def _load_from_group(group: h5py.Group):
            # Load Metadata
            meta = group["metadata"]
            M = int(meta.attrs["M"])
            Nelec = int(meta.attrs["Nelec"])
            num_states = int(meta.attrs["num_states"])
            basis_size = int(meta.attrs["basis_size"])
            energies = meta["energies"][:]
            
            # Reconstruct Basis
            basis_gp = group["basis"]
            transformation_matrix = basis_gp["transformation_matrix"][:] if "transformation_matrix" in basis_gp else None
            
            alpha_indices_flat = basis_gp["alpha_indices_flat"][:]
            alpha_endpoints = basis_gp["alpha_endpoints"][:]
            beta_indices_flat = basis_gp["beta_indices_flat"][:]
            beta_endpoints = basis_gp["beta_endpoints"][:]

            alpha_list = [alpha_indices_flat[alpha_endpoints[i]:alpha_endpoints[i+1]] for i in range(basis_size)]
            beta_list = [beta_indices_flat[beta_endpoints[i]:beta_endpoints[i+1]] for i in range(basis_size)]
            
            basis = [cc.SlaterDeterminant(M, a, b) for a, b in zip(alpha_list, beta_list)]

            # Reconstruct Wavefunctions
            wf_gp = group["wavefunctions"]
            wavefunctions = []
            for i in range(num_states):
                coeffs = wf_gp[f"state_{i}_coeffs"][:]
                wf = cc.Wavefunction(M, basis, coeffs)
                wavefunctions.append(wf)
            
            return cls(M=M, Nelec=Nelec, energies=energies, wavefunctions=wavefunctions,
                       basis=basis, transformation_matrix=transformation_matrix)

        if isinstance(source, str):
            print(f"Loading eigenstate results from file '{source}'...")
            with h5py.File(source, 'r') as f:
                instance = _load_from_group(f)
        else: # Assumes source is an h5py.Group
            print(f"Loading eigenstate results from HDF5 group '{source.name}'...")
            instance = _load_from_group(source)
            
        print("Load complete.")
        return instance

# We define the Boltzmann constant in eV/K.
K_B_IN_EV_PER_K = 8.617333262e-5 # eV/K
k_B_IN_RY_PER_K = 0.0000063336   # Ry/K 

class ThermalGroundState:
    """
    Holds and manages a collection of low-energy eigenstates from different
    particle number (Nelec) sectors to describe a system at a given temperature.

    It is assumed that the chemical potential has already been absorbed into the
    one-body part of the Hamiltonian used to generate these eigenstates.
    """
    def __init__(self,
                 results_by_nelec: dict[int, 'NelecLowEnergySubspace'],
                 base_model: 'Model',
                 temperature: float = 5.0):
        
        if not isinstance(results_by_nelec, dict):
            raise TypeError("`results_by_nelec` must be a dictionary.")

        # --- Store base model information ---
        self.base_h0 = base_model.h0
        self.base_U = base_model.U
        self.M = base_model.M
        self.is_impurity_model = base_model.is_impurity_model
        self.imp_indices = base_model.imp_indices
        
        self.results_by_nelec = results_by_nelec
        self._temperature = temperature
        
        self._all_states: list[tuple[float, int, cc.Wavefunction]] = []
        for nelec, result in self.results_by_nelec.items():
            for i, energy in enumerate(result.energies):
                self._all_states.append((energy, nelec, result.wavefunctions[i]))

        self._all_states.sort(key=lambda s: s[0])
        self.boltzmann_weights: np.ndarray | None = None
        self.partition_function: float | None = None
        self._recalculate_thermal_properties()

    @property
    def temperature(self) -> float:
        """The temperature of the system in Kelvin."""
        return self._temperature

    @temperature.setter
    def temperature(self, value: float):
        """Sets the temperature and recalculates thermal properties."""
        if value <= 0:
            raise ValueError("Temperature must be positive.")
        self._temperature = value
        self._recalculate_thermal_properties()
        
    def _recalculate_thermal_properties(self):
        """
        Internal method to update Boltzmann weights and partition function
        whenever temperature changes.
        """
        if not self._all_states:
            self.boltzmann_weights = np.array([])
            self.partition_function = 0.0
            return

        # Assumes energies are in eV. Change k_B constant if units differ.
        #beta = 1.0 / (K_B_IN_EV_PER_K * self._temperature)
        beta = 1.0 / (k_B_IN_RY_PER_K * self._temperature)
        
        energies = np.array([s[0] for s in self._all_states])
        
        # Subtract the ground state energy to prevent numerical overflow in exp()
        # This factor cancels out upon normalization.
        ground_state_energy = energies[0] # Since the list is sorted
        unnormalized_weights = np.exp(-beta * (energies - ground_state_energy))
        
        self.partition_function = np.sum(unnormalized_weights)
        self.boltzmann_weights = unnormalized_weights / self.partition_function
        
        print(f"Recalculated thermal properties for T={self.temperature} K.")

    def prune(self, threshold: float = 1e-2):
        """
        Removes states whose Boltzmann weight is below a given threshold.
        This method completely rebuilds the internal state of the object,
        purging all information related to the pruned states.
        """
        print("*"*42)
        print(f"DEBUG: PRUNING WITH threshold = {threshold}")
        if self.boltzmann_weights is None:
            self._recalculate_thermal_properties()

        initial_count = len(self._all_states)
        if initial_count == 0:
            print("No states to prune.")
            return

        # 1. Identify which states to keep
        indices_to_keep = np.where(self.boltzmann_weights >= threshold)[0]
        
        if len(indices_to_keep) == initial_count:
            print(f"No states pruned with threshold {threshold:.1e}.")
            return

        # 2. Keep only the surviving states in the flattened list
        self._all_states = [self._all_states[i] for i in indices_to_keep]
        
        # --- 3. CRUCIAL STEP: Rebuild the results_by_nelec dictionary from scratch ---
        new_results_by_nelec = {}
        
        # Group surviving states by their Nelec
        grouped_states = {}
        for energy, nelec, wf in self._all_states:
            if nelec not in grouped_states:
                grouped_states[nelec] = []
            grouped_states[nelec].append({"energy": energy, "wavefunction": wf})

        # For each group, create a new, minimal NelecLowEnergySubspace object
        for nelec, states_info in grouped_states.items():
            states_info.sort(key=lambda x: x["energy"])
            surviving_wfs = [s["wavefunction"] for s in states_info]
            surviving_energies = [s["energy"] for s in states_info]
            
            # Create a minimal basis just for the surviving wavefunctions in this sector
            new_basis_set = set()
            for wf in surviving_wfs:
                new_basis_set.update(wf.data().keys())
            pruned_basis = sorted(list(new_basis_set))
            
            # Re-express the wavefunctions in this new minimal basis
            new_wavefunctions = []
            det_to_idx = {det: i for i, det in enumerate(pruned_basis)}
            original_M = self.results_by_nelec[nelec].M
            for wf in surviving_wfs:
                new_coeffs = np.zeros(len(pruned_basis), dtype=np.complex128)
                for det, coeff in wf.data().items():
                    new_coeffs[det_to_idx[det]] = coeff
                new_wavefunctions.append(cc.Wavefunction(original_M, pruned_basis, new_coeffs))
            
            # Get other metadata from the original object (this is the only time we need it)
            original_transform = self.results_by_nelec[nelec].transformation_matrix

            # Create the new, clean result object for this Nelec sector
            new_results_by_nelec[nelec] = NelecLowEnergySubspace(
                M=original_M,
                Nelec=nelec,
                energies=np.array(surviving_energies),
                wavefunctions=new_wavefunctions,
                basis=pruned_basis,
                transformation_matrix=original_transform
            )

        # 4. Replace the old, complete dictionary with the new, pruned one
        self.results_by_nelec = new_results_by_nelec

        # 5. Finally, recalculate the Boltzmann weights for the pruned set
        self._recalculate_thermal_properties()
        final_count = len(self._all_states)
        print(f"Pruned {initial_count - final_count} states. {final_count} states remaining.")

    def find_absolute_ground_state(self) -> tuple[int, float, cc.Wavefunction]:
        """
        Finds the state with the lowest energy across all calculated Nelec sectors.

        Returns:
            A tuple of (Nelec, ground_state_energy, ground_state_wavefunction).
        """
        if not self._all_states:
            raise ValueError("No states are stored.")

        # Since _all_states is sorted by energy, the ground state is the first one.
        gs_energy, gs_nelec, gs_wf = self._all_states[0]
        return gs_nelec, gs_energy, gs_wf

    def save(self, filename: str):
        """Saves all contained results and model info into a single HDF5 file."""
        print(f"Saving thermal state data to '{filename}'...")
        with h5py.File(filename, 'w') as f:
            f.attrs["file_type"] = "ThermalGroundState"
            f.attrs["temperature"] = self.temperature
            
            # --- Save the base model context ---
            f.attrs["M"] = self.M
            f.attrs["is_impurity_model"] = self.is_impurity_model
            if self.is_impurity_model:
                f.attrs["imp_indices"] = self.imp_indices
            f.create_dataset("base_h0", data=self.base_h0)
            f.create_dataset("base_U", data=self.base_U)

            for nelec, result in self.results_by_nelec.items():
                nelec_group = f.create_group(f"nelec_{nelec}")
                print(f"Saving Nelec={nelec} subspace to HDF5 group '{nelec_group.name}'...")
                result.save(nelec_group)
        print("Save complete.")


    @classmethod
    def load(cls, filename: str):
        """Loads a thermal state result from a single HDF5 file."""
        print(f"Loading thermal state data from '{filename}'...")
        results = {}
        with h5py.File(filename, 'r') as f:
            if f.attrs.get("file_type") != "ThermalGroundState":
                 print(f"Warning: File '{filename}' may not be a valid ThermalGroundState file.")
            
            temp = f.attrs.get("temperature", 300.0)
            
            # Import Model locally to avoid circular dependency at module level
            from .api import Model

            # --- Load the base model context ---
            M = int(f.attrs["M"])
            is_imp = bool(f.attrs["is_impurity_model"])
            imp_indices = list(f.attrs.get("imp_indices", []))
            base_h0 = f["base_h0"][:]
            base_U = f["base_U"][:]
            
            # Reconstruct the model object. Nelec is just a placeholder here.
            loaded_model = Model(h0=base_h0, U=base_U, M_spatial=M, Nelec=-1)
            loaded_model.is_impurity_model = is_imp
            loaded_model.imp_indices = imp_indices

            for key in f.keys():
                if key.startswith("nelec_"):
                    nelec = int(key.split("_")[1])
                    nelec_group = f[key]
                    print(f"Loading Nelec={nelec} subspace from HDF5 group '{nelec_group.name}'...")
                    results[nelec] = NelecLowEnergySubspace.load(nelec_group)
        
        print("Load complete.")
        return cls(results, base_model=loaded_model, temperature=temp)
]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/results[?1h=[1m[37m...[39m[0m[?1l># postprocessing.py
 
import numpy as np
from scipy.sparse import lil_matrix
from . import results
from clic.ops import ops
from ..api import Model

def _get_1p_Sz_matrix(M):
    sz_diag = np.concatenate([np.full(M, 0.5), np.full(M, -0.5)])
    return np.diag(sz_diag)

class StateAnalyzer:
    def __init__(self, result_obj, model: Model):
        if isinstance(result_obj, results.NelecLowEnergySubspace):
            res_dict = {result_obj.Nelec: result_obj}
            self.thermal_state = results.ThermalGroundState(res_dict, temperature=1e-6)
        elif isinstance(result_obj, results.ThermalGroundState):
            self.thermal_state = result_obj
        else:
            raise TypeError("result_obj must be NelecLowEnergySubspace or ThermalGroundState")
        self.model = model
        self._1p_op_cache = {}

    def _get_1p_operators(self):
        if "Sz" in self._1p_op_cache:
            return self._1p_op_cache
        num_imp_spatial = len(self.model.imp_indices)
        Sz_op = _get_1p_Sz_matrix(num_imp_spatial)
        self._1p_op_cache = {"Sz": Sz_op}
        return self._1p_op_cache

    def _calculate_single_state_stats(self, wf, nelec):
        stats = {}

        # many body expectations without building operators
        _, Sz_full = ops.expect_S2(wf, self.model.M)

        # S is only meaningful if eigenstate; still report the derived value
        #S = 0.5 * (np.sqrt(1.0 + 4.0 * np.real(S2)) - 1.0)
        #stats["S2"] = np.real(S2)
        #stats["S"]  = np.real(S)

        if self.model.is_impurity_model:
            imp_spinfull = self.model.imp_indices + [i + self.model.M for i in self.model.imp_indices]
            rdm_imp = ops.one_rdm(wf, self.model.M, block=imp_spinfull)
            stats["occ"] = float(np.sum(np.real(np.diag(rdm_imp))))
            stats["rdm"] = rdm_imp

            op_1p = self._get_1p_operators()
            exp_Sz_imp = np.trace(op_1p["Sz"] @ rdm_imp)
            stats["Sz"] = float(np.real(exp_Sz_imp))
        else:
            stats["occ"] = self.model.Nelec
            stats["rdm"] = None
            # use the full-system Sz from ops.expect_S2 return
            stats["Sz"] = float(np.real(Sz_full))

        return stats

    def print_analysis(self):
        all_states = self.thermal_state._all_states
        weights = self.thermal_state.boltzmann_weights
        if not all_states:
            print("No states to analyze.")
            return

        _, gs_energy, _ = self.thermal_state.find_absolute_ground_state()

        print("-"*50)
        print("RETAINED STATES:")
        print("-"*50)
        print(f"GS: e0 = {gs_energy:.12f}")

        all_stats = []
        avg_rdm_imp = 0
        for i, (energy, nelec, wf) in enumerate(all_states):
            stats = self._calculate_single_state_stats(wf, nelec)
            if self.model.is_impurity_model:
                avg_rdm_imp += weights[i] * stats["rdm"]
            all_stats.append(stats)

            print(f"e-e0: {energy - gs_energy:10.8f}, "
                  f"ne: {nelec}, "
                  f"weight: {weights[i]:10.4f}, "
                  f"occ: {stats['occ']:10.4f}, "
                  #f"S2: {stats['S2']:10.4f}, "
                  #f"S: {stats['S']:10.4f}, "
                  f"Sz: {stats['Sz']:10.4f}")

        if self.model.is_impurity_model:
            print("Saving thermally-averaged impurity density matrix...")
            np.savetxt("real-imp-dens.dat", np.real(avg_rdm_imp), fmt="% 8.5f")
            print("-> Saved 'real-imp-dens.dat'")
            np.savetxt("imag-imp-dens.dat", np.imag(avg_rdm_imp), fmt="% 8.5f")
            print("-> Saved 'imag-imp-dens.dat'")

        if len(all_states) > 1:
            avg_occ = float(np.sum(weights * [s["occ"] for s in all_stats]))
            #avg_S2  = float(np.sum(weights * [s["S2"] for s in all_stats]))
            #avg_S   = float(np.sum(weights * [s["S"]  for s in all_stats]))
            avg_Sz  = float(np.sum(weights * [s["Sz"] for s in all_stats]))
            print("thermal averages:")
            print(f"<occ> = {avg_occ:.8f}")
            #print(f"<S2>  = {avg_S2:.8f}")
            #print(f"<S>   = {avg_S:.8f}")
            print(f"<Sz>  = {avg_Sz:.8f}")
        print("-"*50)]7;file://UU-FVFLJ1WH1WG7/Users/bashe338/work/clic/clic/results[?1h=[?1l>
Saving session...
...copying shared history...
...saving history...truncating history files...
...completed.
